/* @flow
 * @generated by TsFlower
 */
import type { Extract, Partial } from 'tsflower/subst/lib';

import type {
  ReactNode as $tsflower_subst$React$ReactNode,
  JSX$Element as $tsflower_subst$React$JSX$Element,
  ComponentProps as $tsflower_subst$React$ComponentProps,
} from 'tsflower/subst/react';

import * as React from 'react';

import {
  type DefaultRouterOptions,
  type NavigationState,
  type NavigationAction,
  type InitialState,
  type PartialState,
  type Route,
  type ParamListBase,
} from '@react-navigation/routers';

export type DefaultNavigatorOptions<
  ScreenOptions: { ... },
  ParamList: ParamListBase = ParamListBase,
> = DefaultRouterOptions<string> & {
  children: $tsflower_subst$React$ReactNode,
  screenOptions?:
    | ScreenOptions
    | ((props: {
        route: RouteProp<ParamList, $Keys<ParamList>>,
        navigation: any,
        ...
      }) => ScreenOptions),
  defaultScreenOptions?:
    | ScreenOptions
    | ((props: {
        route: RouteProp<ParamList, $Keys<ParamList>>,
        navigation: any,
        options: ScreenOptions,
        ...
      }) => ScreenOptions),
  ...
};

export type EventMapBase = {
  +[key: string]: {|
    +data?: any,
    +canPreventDefault?: boolean,
  |},
};

export type EventMapCore<State: NavigationState<>> = {|
  focus: {| data: void |},
  blur: {| data: void |},
  state: {| data: { state: State, ... } |},
  beforeRemove: {|
    data: { action: NavigationAction, ... },
    canPreventDefault: true,
  |},
|};

export type EventArg<EventName: string, CanPreventDefault: boolean | void = false, Data = void> = {
  +type: EventName,
  +target?: string,
  ...
} & {
  +defaultPrevented: boolean,
  preventDefault(): void,
  ...
} /* CanPreventDefault extends true ? {
    /**
     * Whether `event.preventDefault()` was called on this event object.
     * /
    readonly defaultPrevented: boolean;
    /**
     * Prevent the default action which happens on this event.
     * /
    preventDefault(): void;
} : {} */ /* tsflower-unimplemented: ConditionalType */ & {
  +data: Data,
  ...
} /* undefined extends Data ? {
    readonly data?: Readonly<Data>;
} : {
    readonly data: Readonly<Data>;
} */ /* tsflower-unimplemented: ConditionalType */;

export type EventListenerCallback<EventMap: EventMapBase, EventName: $Keys<EventMap>> = (
  e: EventArg<
    Extract<EventName, string>,
    $ElementType<$ElementType<EventMap, EventName>, 'canPreventDefault'>,
    $ElementType<$ElementType<EventMap, EventName>, 'data'>,
  >,
) => void;

export type EventConsumer<EventMap: EventMapBase> = {
  addListener<EventName: Extract<$Keys<EventMap>, string>>(
    type: EventName,
    callback: EventListenerCallback<EventMap, EventName>,
  ): () => void,
  removeListener<EventName: Extract<$Keys<EventMap>, string>>(
    type: EventName,
    callback: EventListenerCallback<EventMap, EventName>,
  ): void,
  ...
};

export type EventEmitter<EventMap: EventMapBase> = {
  emit<EventName: Extract<$Keys<EventMap>, string>>(
    options: {
      type: EventName,
      target?: string,
      ...
    } & $FlowFixMe /* EventMap[EventName]['canPreventDefault'] extends true ? {
            canPreventDefault: true;
        } : {} */ /* tsflower-unimplemented: ConditionalType */ &
      $FlowFixMe /* undefined extends EventMap[EventName]['data'] ? {
            data?: EventMap[EventName]['data'];
        } : {
            data: EventMap[EventName]['data'];
        } */ /* tsflower-unimplemented: ConditionalType */,
  ): EventArg<
    EventName,
    $ElementType<$ElementType<EventMap, EventName>, 'canPreventDefault'>,
    $ElementType<$ElementType<EventMap, EventName>, 'data'>,
  >,
  ...
};

declare export class PrivateValueStore<+A, +B, C> {
  $tsflower$property$0: $FlowFixMe /* 
    /**
     * UGLY HACK! DO NOT USE THE TYPE!!!
     *
     * TypeScript requires a type to be used to be able to infer it.
     * The type should exist as its own without any operations such as union.
     * So we need to figure out a way to store this type in a property.
     * The problem with a normal property is that it shows up in intelliSense.
     * Adding private keyword works, but the annotation is stripped away in declaration.
     * Turns out if we use an empty string, it doesn't show up in intelliSense.
     * /
    protected ''?: {
        a: A;
        b: B;
        c: C;
    }; */ /* tsflower-unimplemented: empty-named property on class or interface */;
}

type NavigationHelpersCommon<
  +ParamList: ParamListBase,
  State: NavigationState<> = NavigationState<>,
> = {
  dispatch(action: NavigationAction | ((state: State) => NavigationAction)): void,
  // prettier-ignore
  navigate<RouteName: $Keys<ParamList>>(
    ...args: $FlowFixMe /*  undefined extends ParamList[RouteName] ? [RouteName] | [RouteName, ParamList[RouteName]] : [RouteName, ParamList[RouteName]] */ /* tsflower-unimplemented: ConditionalType */
  ): void,
  navigate<RouteName: $Keys<ParamList>>(
    route:
      | {
          key: string,
          params?: $ElementType<ParamList, RouteName>,
          ...
        }
      | {
          name: RouteName,
          key?: string,
          params: $ElementType<ParamList, RouteName>,
          ...
        },
  ): void,
  reset(state: PartialState<State> | State): void,
  goBack(): void,
  isFocused(): boolean,
  canGoBack(): boolean,
  getParent<T = NavigationProp<ParamListBase> | void>(): T,
  getState(): State,
  dangerouslyGetParent<T = NavigationProp<ParamListBase> | void>(): T,
  dangerouslyGetState(): State,
  ...
} & PrivateValueStore<ParamList, $Keys<ParamList>, { ... }>;

export type NavigationHelpers<
  ParamList: ParamListBase,
  EventMap: EventMapBase = EventMapBase,
> = NavigationHelpersCommon<ParamList> &
  EventEmitter<EventMap> & {
    setParams<RouteName: $Keys<ParamList>>(
      params: Partial<$ElementType<ParamList, RouteName>>,
    ): void,
    ...
  };

export type NavigationContainerProps = {
  initialState?: InitialState,
  onStateChange?: (state: NavigationState<> | void) => void,
  onUnhandledAction?: (action: NavigationAction) => void,
  independent?: boolean,
  children: $tsflower_subst$React$ReactNode,
  ...
};

export type NavigationProp<
  +ParamList: ParamListBase,
  +RouteName: $Keys<ParamList> = $Keys<ParamList>,
  State: NavigationState<ParamList> = NavigationState<ParamList>,
  ScreenOptions: { ... } = { ... },
  EventMap: EventMapBase = EventMapBase,
> = NavigationHelpersCommon<ParamList, State> & {
  setParams(params: Partial<$ElementType<ParamList, RouteName>>): void,
  setOptions(options: Partial<ScreenOptions>): void,
  ...
} & EventConsumer<{| ...EventMap, ...EventMapCore<State> |}> &
  PrivateValueStore<ParamList, RouteName, EventMap>;

export type RouteProp<+ParamList: ParamListBase, +RouteName: $Keys<ParamList>> = Route<
  Extract<RouteName, string>,
  $ElementType<ParamList, RouteName>,
>;

export type CompositeNavigationProp<
  A: NavigationProp<ParamListBase, string, any, any>,
  B: NavigationHelpersCommon<ParamListBase, any>,
> = $Diff<A & B, {| [key: $Keys<NavigationProp<any>>]: mixed |}> &
  NavigationProp<
    $FlowFixMe /* A extends NavigationHelpersCommon<infer T> ? T : never */ /* tsflower-unimplemented: ConditionalType */ &
      $FlowFixMe /* B extends NavigationHelpersCommon<infer U> ? U : never */ /* tsflower-unimplemented: ConditionalType */,
    $FlowFixMe /*  
/**
 * The route name should refer to the route name specified in the first type
 * Ideally it should work for any of them, but it's not possible to infer that way
 * /
A extends NavigationProp<any, infer R> ? R : string */ /* tsflower-unimplemented: ConditionalType */,
    $FlowFixMe /*  
/**
 * The type of state should refer to the state specified in the first type
 * /
A extends NavigationProp<any, any, infer S> ? S : NavigationState */ /* tsflower-unimplemented: ConditionalType */,
    $FlowFixMe /* A extends NavigationProp<any, any, any, infer O> ? O : {} */ /* tsflower-unimplemented: ConditionalType */ &
      $FlowFixMe /* B extends NavigationProp<any, any, any, infer P> ? P : {} */ /* tsflower-unimplemented: ConditionalType */,
    $FlowFixMe /*  
/**
 * Event consumer config should refer to the config specified in the first type
 * This allows typechecking `addListener`/`removeListener`
 * /
A extends NavigationProp<any, any, any, any, infer E> ? E : {} */ /* tsflower-unimplemented: ConditionalType */,
  >;

export type Descriptor<
  ParamList: ParamListBase,
  RouteName: $Keys<ParamList> = string,
  State: NavigationState<> = NavigationState<>,
  ScreenOptions: { ... } = { ... },
  EventMap: EventMapBase = EventMapBase,
> = {
  render(): $tsflower_subst$React$JSX$Element,
  options: ScreenOptions,
  navigation: NavigationProp<ParamList, RouteName, State, ScreenOptions, EventMap>,
  ...
};

export type ScreenListeners<
  State: NavigationState<>,
  EventMap: EventMapBase,
> = Partial<$FlowFixMe /* {
    [EventName in keyof (EventMap & EventMapCore<State>)]: EventListenerCallback<EventMap, EventName>;
} */ /* tsflower-unimplemented: MappedType */>;

export type RouteConfig<
  ParamList: ParamListBase,
  RouteName: $Keys<ParamList>,
  State: NavigationState<>,
  ScreenOptions: { ... },
  EventMap: EventMapBase,
> = {
  name: RouteName,
  options?:
    | ScreenOptions
    | ((props: {
        route: RouteProp<ParamList, RouteName>,
        navigation: any,
        ...
      }) => ScreenOptions),
  listeners?:
    | ScreenListeners<State, EventMap>
    | ((props: {
        route: RouteProp<ParamList, RouteName>,
        navigation: any,
        ...
      }) => ScreenListeners<State, EventMap>),
  getId?: ({ params: $ElementType<ParamList, RouteName>, ... }) => string | void,
  initialParams?: Partial<$ElementType<ParamList, RouteName>>,
  ...
} & (
  | {
      component: React.ComponentType<any>,
      getComponent?: empty,
      children?: empty,
      ...
    }
  | {
      getComponent: () => React.ComponentType<any>,
      component?: empty,
      children?: empty,
      ...
    }
  | {
      children: (props: {
        route: RouteProp<ParamList, RouteName>,
        navigation: any,
        ...
      }) => $tsflower_subst$React$ReactNode,
      component?: empty,
      getComponent?: empty,
      ...
    }
);

export type NavigationContainerEventMap = {|
  state: {| data: { state: NavigationState<> | PartialState<NavigationState<>> | void, ... } |},
  options: {| data: { options: { ... }, ... } |},
  __unsafe_action__: {|
    data: {
      action: NavigationAction,
      noop: boolean,
      ...
    },
  |},
|};

export type NavigationContainerRef = NavigationHelpers<ParamListBase> &
  EventConsumer<NavigationContainerEventMap> & {
    resetRoot(state?: PartialState<NavigationState<>> | NavigationState<>): void,
    getRootState(): NavigationState<>,
    getCurrentRoute(): Route<string> | void,
    getCurrentOptions(): { ... } | void,
    ...
  };

export type TypedNavigator<
  ParamList: ParamListBase,
  State: NavigationState<>,
  ScreenOptions: { ... },
  EventMap: EventMapBase,
  Navigator: React.ComponentType<any>,
> = {
  Navigator: React.ComponentType<
    $Diff<
      $tsflower_subst$React$ComponentProps<Navigator>,
      {| [key: $Keys<DefaultNavigatorOptions<any, any>>]: mixed |},
    > &
      DefaultNavigatorOptions<ScreenOptions, ParamList>,
  >,
  Screen: <RouteName: $Keys<ParamList>>(
    _: RouteConfig<ParamList, RouteName, State, ScreenOptions, EventMap>,
  ) => null,
  ...
};

export type NavigatorScreenParams<ParamList, State: NavigationState<> = NavigationState<>> =
  | {
      screen?: empty,
      params?: empty,
      initial?: empty,
      state: PartialState<State> | State | void,
      ...
    }
  | $ElementType<
      $FlowFixMe /*  {
    [RouteName in keyof ParamList]: undefined extends ParamList[RouteName] ? {
        screen: RouteName;
        params?: ParamList[RouteName];
        initial?: boolean;
        state?: never;
    } : {
        screen: RouteName;
        params: ParamList[RouteName];
        initial?: boolean;
        state?: never;
    };
} */ /* tsflower-unimplemented: MappedType */,
      $Keys<ParamList>,
    >;

export type PathConfig = {
  path?: string,
  exact?: boolean,
  parse?: { [key: string]: (value: string) => any },
  stringify?: { [key: string]: (value: any) => string },
  screens?: PathConfigMap,
  initialRouteName?: string,
  ...
};

export type PathConfigMap = { [routeName: string]: string | PathConfig, ... };
export {};
